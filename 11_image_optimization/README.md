# Оптимизация образа контейнера

- [Оптимизация образа контейнера](#оптимизация-образа-контейнера)
  - [Получение информации о размере образа](#получение-информации-о-размере-образа)
  - [Минимальный базовый образ](#минимальный-базовый-образ)
  - [Многоэтапная сборка](#многоэтапная-сборка)
    - [Устаревший подход к процессам сборки](#устаревший-подход-к-процессам-сборки)
      - [Пример](#пример)
    - [Основные принципы многоэтапной сборки](#основные-принципы-многоэтапной-сборки)
      - [Пример многоэтапной сборки](#пример-многоэтапной-сборки)
    - [Общий вид многоэтапной сборки](#общий-вид-многоэтапной-сборки)
  - [Удаление неиспользуемых зависимостей и временных файлов](#удаление-неиспользуемых-зависимостей-и-временных-файлов)
  - [Уменьшение количества слоев](#уменьшение-количества-слоев)
  - [Перепаковка образа](#перепаковка-образа)
  - [Использование .dockerignore](#использование-dockerignore)
  - [Хранение данных вне образа](#хранение-данных-вне-образа)
  - [Кеширование слоев образа](#кеширование-слоев-образа)
  - [Библиография](#библиография)

Простота определения образов контейнеров позволяет их быстро создавать и использовать, а это в свою очередь ведет к допущению ошибок и созданию избыточных образов. Обычным делом является создание образа размеров в несколько гигабайт, что явно является ошибкой. Скорее всего данный образ содержит в себе данные, которые могут быть вынесены во внешние тома или вообще не нужны; ненужные зависимости, которые могут быть удалены; временные файлы и кэш, которые могут быть очищены; и т.д.

Большой размер образа имеет следующие недостатки:

- долгое время загрузки образа из репозитория;
- занимает больше места на диске;
- занимают больше места в памяти.

То есть большой образ требует больше ресурсов для загрузки, хранения и запуска. Поэтому оптимизация образа контейнера является важным шагом в разработке и использовании контейнеров.

## Получение информации о размере образа

Чтобы просмотреть список образов, можно воспользоваться командой `docker images` (или `docker image ls`). Выполнение этой команды покажет список образов, включая их размеры. Например:

```shell
$ docker images
docker image ls
REPOSITORY   TAG       IMAGE ID       CREATED      SIZE
lab07        latest    4e96acf7022c   5 days ago   468MB
<none>       <none>    3de1890f5bde   5 days ago   468MB
myphp        latest    ec1fdb037c54   8 days ago   162MB
```

Получение информации о слоях образа можно выполнить с помощью команды `docker history`. Например:

```shell
$ docker history myphp
IMAGE          CREATED      CREATED BY                                      SIZE      COMMENT
ec1fdb037c54   8 days ago   CMD ["/app/php" "-v"]                           0B        buildkit.dockerfile.v0
<missing>      8 days ago   WORKDIR /app                                    0B        buildkit.dockerfile.v0
<missing>      8 days ago   COPY /usr/lib/x86_64-linux-gnu/libicui18n.so…   3.31MB    buildkit.dockerfile.v0
<missing>      8 days ago   COPY /usr/lib/x86_64-linux-gnu/libicudata.so…   31.3MB    buildkit.dockerfile.v0
<missing>      8 days ago   COPY /usr/lib/x86_64-linux-gnu/libicuuc.so.7…   2.08MB    buildkit.dockerfile.v0
<missing>      8 days ago   COPY /usr/lib/x86_64-linux-gnu/libsqlite3.so…   1.44MB    buildkit.dockerfile.v0
<missing>      8 days ago   COPY /usr/lib/x86_64-linux-gnu/libgmp.so.10 …   529kB     buildkit.dockerfile.v0
<missing>      8 days ago   COPY /usr/lib/x86_64-linux-gnu/libpspell.so.…   14kB      buildkit.dockerfile.v0
<missing>      8 days ago   COPY /usr/lib/x86_64-linux-gnu/libmariadb.so…   337kB     buildkit.dockerfile.v0
<missing>      8 days ago   COPY /usr/lib/x86_64-linux-gnu/libxml2.so.2 …   1.75MB    buildkit.dockerfile.v0
<missing>      8 days ago   COPY /app/php/sapi/cli/php /app/php # buildk…   40.7MB    buildkit.dockerfile.v0
<missing>      9 days ago   /bin/sh -c #(nop)  CMD ["bash"]                 0B
<missing>      9 days ago   /bin/sh -c #(nop) ADD file:5d6b639e8b6bcc011…   80.6MB
```

## Минимальный базовый образ

Создание своего образа контейнера начинается с выбора базового образа. И чем меньше размер базового образа, тем меньше будет размер конечного образа. Например, можно использовать образ `alpine`, который имеет размер около 7 МБ, вместо `ubuntu`, который имеет размер около 80 МБ.

Также можно использовать образ `scratch`, который не содержит ничего, и добавить в него только необходимые файлы и зависимости. Однако, часто разработчикам при работе их приложения нужны некоторые свойства операционной системы, поэтому они останавливаются на образе `alpine` как на минимальном базовом образе.

Можно выбирать специализированные образы под конкретные задачи, которые часто предлагают оптимизированные версии. Например для Python можно использовать образ `python:alpine`, который содержит минимальный набор пакетов для работы с Python.

## Многоэтапная сборка

Многоэтапная сборка позволяет уменьшить размер образа контейнера, так как в конечном образе остаются только необходимые файлы и зависимости. Например, можно использовать образ с компилятором для сборки приложения, а затем скопировать только исполняемый файл в конечный образ.

Чтобы создать действительно эффективный, маленький и безопасный образ, рекомендуется выполнять процесс сборки в несколько этапов. Каждый этап сборки выполняется в отдельном контейнере и результат его работы сохраняется в образе. В итоге, вместо одного большого образа, создаётся несколько промежуточных, хранящих результаты работы каждого этапа. В финальном образе будут только те файлы, которые необходимы для работы приложения.

### Устаревший подход к процессам сборки

Процесс разработки программного продукта включает следующие шаги:

- Настройка окружения
- Написание кода
- Компиляция и сборка
- Тестирование
- Развертывание

Похожим образом происходит сборка Docker-образа:

- Настройка окружения
- Установка зависимостей
- Сборка приложения
- Тестирование
- Развертывание контейнера

Для каждого этапа сборки создавался отдельный контейнер, который выполнял свою задачу. Например, для установки зависимостей использовался контейнер с установленным компилятором и библиотеками, для сборки приложения - контейнер с установленным компилятором и библиотеками, для тестирования - контейнер с установленным тестовым фреймворком и т.д. В конце результаты работы каждого контейнера объединялись в один образ.

Соответственно, для каждого этапа создавался свой `Dockerfile`, который выполнял свою задачу, а также скрипт для объединения результатов работы контейнеров в один образ.

#### Пример

Пусть у нас есть приложение CPP (файл `helloworld.cpp`), которое мы хотим запустить в контейнере.

```cpp
#include <iostream>

int main() {
    std::cout << "Hello, World!" << std::endl;
    return 0;
}
```

Для сборки образа создадим следующие файлы:

- `Dockerfile.build` - для сборки приложения
- `Dockerfile.run` - для запуска приложения
- `build.sh` - скрипт для сборки образа

`Dockefile.build`:

```Dockerfile
FROM gcc:latest AS build

WORKDIR /app

COPY helloworld.cpp .

RUN g++ helloworld.cpp -o helloworld -static
```

`Dockerfile.run`:

```Dockerfile
FROM debian:latest

WORKDIR /app

COPY app/helloworld .

CMD ["./helloworld"]
```

`build.sh`:

```bash
#!/bin/bash
echo "Building helloworld-build image..."
docker build -t helloworld-build -f Dockerfile.build .

echo "Extracting helloworld binary..."
mkdir -p app
docker create --name extract helloworld-build
docker cp extract:/app/helloworld app/helloworld
docker rm -f extract

echo "Building helloworld-run image..."
docker build -t helloworld-run -f Dockerfile.run .
rm -f app/helloworld
```

При запуске скрипта `build.sh`:

- создается образ `helloworld-build`, который собирает приложение;
- запускается контейнер `extract`, в котором собранное приложение копируется на хост-машину;
- удаляется контейнер `extract`;
- создается образ `helloworld-run`, который запускает приложение.

Использование многоэтапной сборки позволяет упростить процесс сборки образа и уменьшить его размер.

### Основные принципы многоэтапной сборки

Многоэтапная сборка позволяет создавать образы, которые содержат только необходимые для работы приложения файлы, используя только один Dockerfile. Для этого используются следующие принципы:

- Каждая инструкция использует некоторый базовый образ и задаёт этап сборки;
- Каждый этап сборки выполняется в отдельном контейнере;
- Результат работы каждого этапа сохраняется в образе;
- Можно копировать файлы из одного этапа в другой.

#### Пример многоэтапной сборки

В этом случае наш пример можно упростить до одного `Dockerfile`:

```Dockerfile
FROM gcc:latest AS build

WORKDIR /app

COPY helloworld.cpp .

RUN g++ helloworld.cpp -o helloworld -static

FROM debian:latest

WORKDIR /app

COPY --from=0 app/helloworld .

CMD ["./helloworld"]
```

Сборка образа в этом случае сокращается до одной команды:

```bash
docker build -t helloworld-run .
```

Это возможно благодаря тому что инструкция `COPY` может копировать файлы из одного этапа в другой, при этом необходимо указать номер этапа, из которого нужно скопировать файлы.

Кроме того, можно этапам сборки задавать имена, чтобы обращаться к ним по имени:

```Dockerfile
FROM gcc:latest AS build

WORKDIR /app

COPY helloworld.cpp .

RUN g++ helloworld.cpp -o helloworld

FROM debian:latest AS run

WORKDIR /app

COPY --from=build app/helloworld .

CMD ["./helloworld"]
```

### Общий вид многоэтапной сборки

Естественно, многоэтапная сборка позволяет не только собирать приложения, но и выполнять другие задачи: тестирование, анализ кода, сборку документации и т.д.

В общем виде многоэтапная сборка может выглядеть следующим образом:

```Dockerfile
# создание базового образа
FROM debian:latest AS base

# ...

# установка зависимостей
FROM base AS dependencies

# ...

# сборка приложения
FROM dependencies AS build

# ...

# тестирование приложения
FROM build AS test

# ...

# развертывание приложения
FROM debian

# копирование файлов из других этапов
COPY --from=build /app/app /app/app

# запуск приложения
CMD ["./app"]
```

## Удаление неиспользуемых зависимостей и временных файлов

Удаление неиспользуемых зависимостей позволяет уменьшить размер образа контейнера. Например, после установки пакетов можно удалить временные файлы и кэш, чтобы уменьшить размер образа.

Данная процедура имеет смысл в случае объединения слоёв образа или в случае перепаковки образа. В противном случае, удаление временных файлов и кэша не приведет к уменьшению размера образа.

## Уменьшение количества слоев

Образ хранит информацию о каждом слое, что увеличивает его размер. Кроме того, каждый слой образа представляется промежуточным образом, хранение которого требует дополнительного места на диске.

Объединение команд в один слой позволяет уменьшить количество промежуточных образов, а также уменьшить размер образа за счет уменьшения количества метаданных. Кроме того, невозможно создать образ меньшего размера если промежуточные образы имеют больший размер.

Вместо создания временного слоя для установки пакетов и удаления кэша, можно выполнить все команды в одном слое.

Например, образ, построенный на базе `Dockefile`:

```dockerfile
FROM debian:bookworm-slim

RUN apt-get update && apt-get install -y php-cli
```

будет иметь примерно тот же размер, что и образ, построенный на базе `Dockerfile`:

```dockerfile
FROM debian:bookworm-slim

RUN apt-get update && apt-get install -y php-cli
RUN apt-get clean && rm -rf /var/lib/apt/lists/* /tmp/* /var/tmp/*
```

Однако объединение команд в один слой позволяет уменьшить размер образа:

```dockerfile
FROM debian:bookworm-slim

RUN apt-get update && \
    apt-get install -y php-cli && \
    apt-get clean && \
    rm -rf /var/lib/apt/lists/* /tmp/* /var/tmp/*
```

## Перепаковка образа

Перепаковка образа позволяет слить все слои образа в один слой, что уменьшает размер образа.

> Примечание: перепаковка образа приводит к потере преимущества совместного использования слоёв образа разными образами. Кроме того, теряются все метаданные образа, а также открываемые порты, переменные окружения и т.д. Использовать данный способ можно только если вы пытаетесь оптимизировать чужой образ.

Для перепаковки образа можно воспользоваться тем фактом, что при создании контейнера сливает все слои образа в один слой. Например, можно создать контейнер из образа и затем создать образ из контейнера.

Если образ называется `myphp`, то перепаковка образа будет выглядеть следующим образом:

```shell
# Создание контейнера из образа
$ docker create --name myphp myphp
# Создание образа из контейнера
$ docker export myphp | docker import - myphp:optimized
```

## Использование .dockerignore

Использование файла `.dockerignore` позволяет исключить из контекста сборки файлы и директории, которые не нужны для создания образа. Частой практикой является копирование всего контекста сборки, что ведет к включению в образ ненужных файлов и директорий. Поэтому рекомендуется использовать файл `.dockerignore` для исключения ненужных файлов и директорий.

Пример файла `.dockerignore`:

```dockerfile
# .dockerignore
.git
.vscode
__pycache__
*.pyc
```

## Хранение данных вне образа

Хранение данных вне образа позволяет уменьшить размер образа контейнера. Например, можно использовать внешние тома для хранения web приложения. Однако следует помнить, что внешние тома могут быть сетевыми дисками, что может увеличить время работы приложения за счет сетевой задержки.

## Кеширование слоев образа

Docker активно использует кеширование слоев образа, что позволяет ускорить сборку образа. Однако, кеширование слоев образа приводит к потребления дисковой памяти. Чтобы эффективно использовать кеширование необходимо учитывать порядок команд в `Dockerfile` и использовать многоэтапную сборку.

При изменении команды `RUN` все последующие команды будут пересобраны, что приведет к увеличению времени сборки образа. Поэтому необходимо сначала выполнять команды, которые меньше подвержены изменениям (например, настройка окружения), а затем выполнять команды, которые чаще изменяются (копирование приложения).

В указанном примере образ будет пересобираться полностью при каждом изменении приложения:

```dockerfile
FROM nginx

COPY . /usr/share/nginx/html
RUN apt-get update && apt-get install -y php-cli
```

Однако, если поменять местами команды `RUN` и `COPY`, то при изменении приложения образ будет пересобираться только частично, что ускорит сборку образа:

```dockerfile
FROM nginx

RUN apt-get update && apt-get install -y php-cli

COPY . /usr/share/nginx/html
```

## Библиография

1. [Predrag Rakić, Docker Image Size – Does It Matter?, semaphoreci.com, 2021-03-30](https://semaphoreci.com/blog/2018/03/14/docker-image-size.html)
2. [Rafael Benevides, Keep it small: a closer look at Docker image sizing, RedHat, 2016-03-09](https://developers.redhat.com/blog/2016/03/09/more-about-docker-images-size)
3. [Bibin Wilson, Shishir Khandelwal, How to Reduce Docker Image Size: 6 Optimization Methods, devopscube.com, 2023-08-22](https://devopscube.com/reduce-docker-image-size/)
4. [Jeff Hale, Slimming Down Your Docker Images, towardsdatascience.com, 2019-01-31](https://towardsdatascience.com/slimming-down-your-docker-images-275f0ca9337e)
5. [pxeno, Полное руководство по созданию Docker-образа для обслуживания системы машинного обучения в продакшене, habr.com](https://habr.com/ru/companies/vk/articles/548480/)
6. [BOOTLOADER, Многоэтапные (multi-stage builds) сборки в Docker, habr.com](https://habr.com/ru/articles/349802/)
7. [Использование многоэтапных (multi-stage) сборок в Docker, cloud.croc.ru](https://cloud.croc.ru/blog/about-technologies/multi-stage-v-docker/)
8. [Docker, Multi-stage builds, docs.docker.com](https://docs.docker.com/build/building/multi-stage/)
