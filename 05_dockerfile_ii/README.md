# Дополнительные директивы Dockerfile

- [Дополнительные директивы Dockerfile](#дополнительные-директивы-dockerfile)
  - [Переменные при построении образа](#переменные-при-построении-образа)
    - [ARG](#arg)
    - [ENV](#env)
  - [Взаимодействие с контейнером](#взаимодействие-с-контейнером)
    - [EXPOSE](#expose)
    - [VOLUME](#volume)
  - [Метаданные образа](#метаданные-образа)
    - [LABEL](#label)
  - [Дополнительные команды](#дополнительные-команды)
    - [SHELL](#shell)
    - [ONBUILD](#onbuild)
    - [HEALTHCHECK](#healthcheck)
    - [STOPSIGNAL](#stopsignal)
  - [Библиография](#библиография)

В данной главе рассматриваются дополнительные директивы `Dockerfile`, которые позволяют определить переменные при построении образа, взаимодействие с контейнером, метаданные образа и дополнительные команды.

## Переменные при построении образа

При построении образа контейнера часто возникает необходимость передать в образ некоторые параметры. Например, можно иметь общий `Dockerfile` для нескольких проектов, в котором различаются только некоторые параметры. Кроме того, можно передать в образ некоторые конфиденциальные данные, такие как пароли, токены и т.п.

Также во время построения образа можно использовать переменные окружения, которые будут доступны во время выполнения контейнера.

### ARG

Команда `ARG` задаёт аргументы, которые можно передать при сборке образа. Аргументы могут быть использованы в командах `FROM`, `RUN`, `CMD`, `LABEL` и `MAINTAINER`. Аргументы могут быть переданы при сборке образа с помощью флага `--build-arg`.

```dockerfile
ARG <name>[=<default value>]
```

где `<name>` - имя аргумента, `<default value>` - значение аргумента по умолчанию.

Пример использования аргументов:

```dockerfile
ARG VERSION=latest

FROM ubuntu:$VERSION
```

Пример передачи аргументов при сборке образа:

```bash
docker build --build-arg VERSION=18.04 -t myimage .
```

### ENV

Команда `ENV` задаёт переменные окружения. Переменные окружения будут доступны во время выполнения контейнера. Переменные окружения могут быть использованы в командах `RUN`, `CMD`, `ENTRYPOINT`, `COPY`, `ADD` и `WORKDIR`.

```dockerfile
ENV <key> <value>
```

где `<key>` - имя переменной окружения, `<value>` - значение переменной окружения.

Пример использования переменных окружения:

```dockerfile
FROM ubuntu:18.04
ENV MY_NAME="John Doe"

RUN echo "Hello, $MY_NAME"
```

Разница между `ARG` и `ENV` заключается в том, что `ARG` используется только во время сборки образа, а `ENV` - во время выполнения контейнера. Если необходимо передать информацию для использования во время выполнения контейнера, то можно воспользоваться определением `ENV` через `ARG`:

```dockerfile
ARG MY_NAME="John Doe"
FROM ubuntu:18.04
ENV MY_NAME=$MY_NAME

RUN echo "Hello, $MY_NAME"
```

Переменные окружения можно переопределить при запуске контейнера с помощью флага `-e` команды `docker run`:

```bash
docker run -e MY_NAME="Jane Doe" myimage
```

## Взаимодействие с контейнером

Контейнер является изолированной сущностью, поэтому, чтобы контейнер мог взаимодействовать с внешними системами, необходимо определить некоторые параметры контейнера. Например, можно определить порты, которые контейнер будет использовать для взаимодействия с внешними системами, а также определить тома, которые контейнер будет использовать для хранения данных.

### EXPOSE

Команда `EXPOSE` определяет порты, которые контейнер будет использовать для взаимодействия с внешними системами. Команда `EXPOSE` имеет следующий синтаксис:

```dockerfile
EXPOSE <port> [<port>...]
```

где `<port>` - номер открываемого для доступа в контейнер порта.

Пример использования команды `EXPOSE`:

```dockerfile
FROM ubuntu:18.04

EXPOSE 80
```

Порты, определённые командой `EXPOSE`, доступны другим контейнерам, но не доступны хосту. Их можно перенаправить на порты хоста с помощью флага `-p` (или `--publish`) команды `docker run`, например:

```bash
docker run -p 80 myimage
```

В этом случае порт 80 контейнера будет ассоциирован с произвольным портом хоста. Чтобы ассоциировать порт контейнера с определённым портом хоста, необходимо указать порт хоста перед двоеточием, например:

```bash
docker run -p 8080:80 myimage
```

В этом случае порт 80 контейнера будет ассоциирован с портом 8080 хоста.

### VOLUME

Команда `VOLUME` определяет тома, которые контейнер будет использовать для хранения данных. Том обеспечивает доступ к файловой системе хоста, а также сохраняет данные, записанные контейнером, после завершения контейнера. Обычно они хранятся в каталоге `/var/lib/docker/volumes` на хосте, но могут быть перенаправлены в другие места.

Команда `VOLUME` имеет следующий синтаксис:

```dockerfile
VOLUME <path> [<path>...]
```

где `<path>` - путь к тому, который будет использоваться контейнером. Данный том будет доступен для записи во время выполнения контейнера, размещается в файловой системе хоста и, по завершении контейнера, данные, записанные контейнером сохраняются.

Пример использования команды `VOLUME`:

```dockerfile
FROM ubuntu:18.04

VOLUME /var/www
```

Можно также определить томы во время выполнения контейнера с помощью флага `-v` команды `docker run`:

```bash
docker run -v /var/www myimage
```

Также можно монтировать папки хоста в контейнер с помощью флага `-v` команды `docker run`:

```bash
docker run -v /path/to/host:/path/to/container myimage
```

## Метаданные образа

Метаданные образа - это информация о создателе образа, описании образа, контактной информации и т.п. Метаданные образа могут быть использованы для поиска образов, для автоматизации процесса сборки образов, для автоматизации процесса развертывания образов.

### LABEL

Команда `LABEL` определяет метаданные образа (метки). Команда `LABEL` имеет следующий синтаксис:

```dockerfile
LABEL <key> = <value> <key> = <value>...
```

где `<key>` - ключ метки, `<value>` - её значение. Метаданные могут быть использованы для поиска образов, для автоматизации процесса сборки образов, для автоматизации процесса развертывания образов.

Пример использования команды `LABEL`:

```dockerfile
FROM ubuntu:18.04

LABEL version="1.0"

RUN echo "Hello, world"
```

Метаданные образа можно просмотреть с помощью команды `docker inspect`:

```bash
docker inspect myimage
```

При определении метаданных образа следует придерживаться следующих рекомендаций:

- авторы сторонних пакетов должны использовать префикс для ключа, который представляет инвертированную доменную запись, например, `com.example-vendor=ACME Incorporated`. Данный префикс представляет собой пространство имен;
- используйте префиксы ключей (пространства имён) только с разрешения владельца домена;
- префиксы `com.docker.*`, `io.docker.*`, и `org.dockerproject.*` зарезервированы для внутреннего использования Docker.
- ключ метки должен начинаться строчной буквой и заканчиваться ею же, должен содержать только строчные буквы, цифры или символы `.`, `-`. Не разрешается последовательное использование специальных символов.
- символ точки `.` разделяют вложенные пространства имён. Ключи меток без пространства имён используются в консольном (CLI) режиме, для того чтобы помечать объекты Docker используя короткие, дружественные для записи строки.

## Дополнительные команды

### SHELL

Команда `SHELL` определяет командную оболочку, которая будет использоваться для выполнения команд `RUN`, `CMD`, `ENTRYPOINT`. Команда `SHELL` имеет следующий синтаксис:

```dockerfile
SHELL ["executable", "parameters"]
```

где `executable` - исполняемый файл командной оболочки, `parameters` - параметры командной оболочки.

Пример использования команды `SHELL`:

```dockerfile
FROM ubuntu:18.04

SHELL ["/bin/bash", "-c"]

RUN echo "Hello, world"
```

В описании образа оболочку можно переопределять несколько раз, и это будет влиять на все последующие команды `RUN`, `CMD` и `ENTRYPOINT`, вплоть до следующего определения команды `SHELL`:

```dockerfile
FROM microsoft/windowsservercore

# проверяем оболочку по умолчанию
RUN echo default shell is %COMSPEC%

# переопределяем оболочку
SHELL ["powershell", "-Command"]

# проверяем оболочку
RUN Write-Host default shell is %COMSPEC%
```

### ONBUILD

Команда `ONBUILD` определяет команды, которые будут выполнены при сборке образа, на основе которого будет создан новый образ. Команда `ONBUILD` имеет следующий синтаксис:

```dockerfile
ONBUILD <command>
```

где `<command>` - команда, которая будет выполнена при сборке образа, на основе которого будет создан новый образ.

Пример использования команды `ONBUILD`:

```dockerfile
FROM ubuntu:18.04

ONBUILD ADD . /app/src
ONBUILD RUN /usr/local/bin/python-build --dir /app/src
```

### HEALTHCHECK

Инструкция `HEALTHCHECK` определяет команду, которая будет выполняться для проверки состояния контейнера. Команда `HEALTHCHECK` имеет следующий синтаксис:

```dockerfile
HEALTHCHECK [OPTIONS] CMD command
```

где `OPTIONS` - опции команды, `CMD` - команда, которая будет выполнена для проверки состояния контейнера.

Также можно отключить проверку состояния контейнера с помощью команды `HEALTHCHECK`:

```dockerfile
HEALTHCHECK NONE
```

Свойства, которые можно определить перед `CMD`:

- `--interval=DURATION` - интервал между проверками состояния контейнера. По умолчанию интервал составляет 30 секунд;
- `--timeout=DURATION` - время ожидания выполнения команды проверки состояния контейнера. По умолчанию время ожидания составляет 30 секунд;
- `--start-period=DURATION` - время ожидания перед началом выполнения команды проверки состояния контейнера. По умолчанию время ожидания составляет 0 секунд;
- `--start-interval=DURATION` - интервал между попытками выполнения команды проверки состояния контейнера при запуске. По умолчанию интервал составляет 5 секунд. Для использования данного свойства необходимо иметь версию Docker Engine 25.0 или выше;
- `--retries=N` - количество попыток выполнения команды проверки состояния контейнера. По умолчанию количество попыток составляет 3.

Команда, указанная после `CMD`, должна возвращать код состояния

- `0` - контейнер готов к работе;
- `1` - контейнер работает с ошибками;
- `2` - зарезервировано для будущего использования, не использовать в настоящее время.

Пример использования команды `HEALTHCHECK`:

```dockerfile
FROM ubuntu:18.04

HEALTHCHECK --interval=5m --timeout=3s \
  CMD curl -f http://localhost/ || exit 1
```

### STOPSIGNAL

Команда `STOPSIGNAL` определяет сигнал, который будет отправлен контейнеру для остановки. Команда `STOPSIGNAL` имеет следующий синтаксис:

```dockerfile
STOPSIGNAL signal
```

где `signal` - сигнал, который будет отправлен контейнеру для остановки. Сигнал может быть указан в виде числа или в виде имени сигнала. Наиболее часто используемые сигналы:

- `SIGINT` - сигнал прерывания процесса, имеет числовое значение `2`;
- `SIGQUIT` - сигнал завершения процесса, имеет числовое значение `3`;
- `SIGTERM` - сигнал завершения процесса, имеет числовое значение `15`, по умолчанию используется данный сигнал;
- `SIGKILL` - сигнал немедленного завершения процесса, имеет числовое значение `9`.

Значение сигнала остановки можно переопределить при запуске контейнера с помощью флага `--stop-signal` команды `docker run`:

```bash
docker run --stop-signal=SIGKILL myimage
```

## Библиография

1. [Dockerfile reference, docker.com](https://docs.docker.com/engine/reference/builder/)
2. [vsupalov, __Docker ARG vs ENV__, vsupalov.com](https://vsupalov.com/docker-arg-vs-env/)
3. [Docker object labels, docker.com](https://docs.docker.com/config/labels-custom-metadata/)
4. [Overview of best practices for writing Dockerfiles](https://docs.docker.com/develop/develop-images/dockerfile_best-practices/)
